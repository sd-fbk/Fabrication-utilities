from typing import (
    TYPE_CHECKING,
)

import numpy as np
import plotly.graph_objects as go
from nomad.datamodel.data import (
    ArchiveSection,
    EntryData,
)
from nomad.datamodel.metainfo.plot import PlotlyFigure, PlotSection
from nomad.metainfo import (
    MEnum,
    Package,
    Quantity,
    Section,
    SubSection,
)
from schema_packages.utils import FabricationChemical

if TYPE_CHECKING:
    from nomad.datamodel.datamodel import (
        EntryArchive,
    )
    from structlog.stdlib import (
        BoundLogger,
    )

m_package = Package(name='Items plugin')


# In questa parte del plugin non mi piace come si inseriscono le proprietÃ  degli items
# forse sarebbe il caso di definirle una per una


class ItemPropertyDefinition(ArchiveSection):
    m_def = Section(
        a_eln={
            'properties': {
                'order': [
                    'name',
                    'description',
                    'id',
                    #                    'value',
                ]
            }
        },
    )
    id = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    name = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    description = Quantity(
        type=str,
        a_eln={'component': 'RichTextEditQuantity'},
    )

    # value = Quantity(
    #     type=np.float64,
    #     a_eln={'component': 'NumberEditQuantity'},
    # )


class ItemShapeType(ArchiveSection):
    m_def = Section(
        a_eln={
            'properties': {
                'order': [
                    'name',
                    'description',
                    'id',
                ]
            }
        },
    )

    id = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    name = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    description = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )


class ListOfItemPropertyDefinition(EntryData, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        a_eln={
            'properties': {
                'order': [
                    'name',
                    'description',
                    'id',
                ]
            }
        },
    )

    name = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    description = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    id = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    list_of_possible_properties = SubSection(
        section_def=ItemPropertyDefinition,
        repeats=True,
    )
    list_of_items_shape_type = SubSection(
        section_def=ItemShapeType,
        repeats=True,
    )


class Contour(ArchiveSection):
    m_def = Section(
        description="""
        Ideal class to desceibe geometric shape used as base for other definitions
        """
    )


class Square(Contour):
    m_def = Section(
        description="""
        Class to describe square shapes of items or objects of fabrication
        """
    )

    side = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'cm'},
        unit='cm',
    )


class Circle(Contour):
    m_def = Section(
        description="""
        Class to describe circular shapes of items or objects of fabrication
        """
    )

    radius = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'cm'},
        unit='cm',
    )


class Rectangle(Contour):
    m_def = Section(
        description="""
        Class usable to describe rectangle shapes of items or objects in fabrication
        """
    )

    base = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'cm'},
        unit='cm',
    )

    height = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'cm'},
        unit='cm',
    )


def make_geometric_represent(chuck, x, y, finalist):
    posizione_centro = [(x, y)]
    # Chuck creation
    fig = go.Figure()
    if chuck is not None:
        if isinstance(chuck, Circle):
            theta = np.linspace(0, 2 * np.pi, 100)
            x_cerchio = chuck.radius * np.cos(theta)
            y_cerchio = chuck.radius * np.sin(theta)
            fig.add_trace(
                go.Scatter(
                    x=x_cerchio, y=y_cerchio, mode='lines', fill='toself', name='Chuck'
                )
            )
        else:
            if isinstance(chuck, Square):
                half = chuck.side / 2
                x_quad = [-half, half, half, -half, -half]
                y_quad = [-half, -half, half, half, -half]
                fig.add_trace(
                    go.Scatter(
                        x=x_quad, y=y_quad, mode='lines', fill='toself', name='Chuck'
                    )
                )
            if isinstance(chuck, Rectangle):
                half_base = chuck.base / 2
                half_height = chuck.height / 2
                x_quad = [-half_base, half_base, half_base, -half_base, -half_base]
                y_quad = [
                    -half_height,
                    -half_height,
                    half_height,
                    half_height,
                    -half_height,
                ]
                fig.add_trace(
                    go.Scatter(
                        x=x_quad, y=y_quad, mode='lines', fill='toself', name='Chuck'
                    )
                )
        for i, (x1, y1) in enumerate(posizione_centro):
            fig.add_trace(
                go.Scatter(
                    x=[x1],
                    y=[y1],
                    mode='markers',
                    marker=dict(size=10, color='red'),
                    name=f'Quadratino {i + 1} centro',
                )
            )
        fig.update_layout(
            title='Item centering on chuck/chamber',
            width=800,
            height=800,
        )
        figure_json = fig.to_plotly_json()
        figure_json['config'] = {'staticPlot': True}
        finalist.append(
            PlotlyFigure(
                label='Chuck vision',
                figure=figure_json,
                index=0,
            )
        )


class ItemPlacement(PlotSection, EntryData):
    m_def = Section(
        description="""
        Section used to describe, if needed, item placement on chucks. The reference
        frame is centered on the chuck center (considered aligned to the chamber
        center) so displacemnt of center of items is given with respect the chuck
        center. If no chuck is provided you can use the chuck for describing the
        chamber shape, ideally the role is similar in these cases.
        """
    )

    item_center_x = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'cm'},
        unit='cm',
    )

    item_center_y = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'cm'},
        unit='cm',
    )

    chuck_geometry = SubSection(
        section_def=Contour,
        repeats=False,
    )

    item_geometry = SubSection(
        section_def=Contour,
        repeats=False,
    )

    def normalize(self, archive, logger):
        super().normalize(archive, logger)
        if hasattr(self, 'figures') and self.figures:
            self.figures.clear()
        make_geometric_represent(
            self.chuck_geometry, self.item_center_x, self.item_center_y, self.figures
        )


class ItemsPermitted(ArchiveSection):
    m_def = Section()

    item_shape = Quantity(
        description='Intended as the way of presenting of the sample processable.',
        type=MEnum(
            'Wafer with flat standard',
            'Wafer with flat JEIDA',
            'Rectangle shape',
            '1/2 wafer',
            '1/4 wafer',
            'Fragment',
            'Square shape',
            'Powder',
            'Wafer with Notch standard',
            'Other (specify in notes)',
        ),
        shape=['*'],
        a_eln={'component': 'EnumEditQuantity'},
    )
    min_length = Quantity(
        type=np.float64,
        description="""
        Is intended as on of the edge of a parallelepipedum shape allowed.
        """,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'mm'},
        unit='mm',
    )

    max_length = Quantity(
        type=np.float64,
        description="""
        Is intended as one of the edge of a parallelepipedum shape allowed.
        """,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'mm'},
        unit='mm',
    )
    min_width = Quantity(
        type=np.float64,
        description="""
            Is intended as one of the edge of a parallelepipedum shape allowed.
        """,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'mm'},
        unit='mm',
    )

    max_width = Quantity(
        type=np.float64,
        description="""
            Is intended as one of the edge of a parallelepipedum shape allowed.
        """,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'mm'},
        unit='mm',
    )
    min_thickness = Quantity(
        type=np.float64,
        description="""
            Is intended as one of the edge of a parallelepipedum shape allowed.
        """,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'mm'},
        unit='mm',
    )

    max_thickness = Quantity(
        type=np.float64,
        description="""
            Is intended as one of the height of a parallelepipedum shape allowed.
        """,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'mm'},
        unit='mm',
    )
    min_weight = Quantity(
        type=np.float64,
        description="""
            Minimuum weight of a processable item
        """,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'g'},
        unit='g',
    )
    max_weight = Quantity(
        type=np.float64,
        description="""
            Maximuum weight of a processable item
        """,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'g'},
        unit='g',
    )
    notes = Quantity(
        type=str,
        a_eln={'component': 'RichTextEditQuantity'},
    )


class ItemComponent(FabricationChemical):
    m_def = Section(
        a_eln={
            'properties': {
                'order': [
                    'name',
                    'description',
                    'chemical_formula',
                    'component_id',
                    'datetime',
                ],
            },
        }
    )
    component_id = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    datetime = Quantity(
        a_eln={'component': 'DateTimeEditQuantity'},
        description='Date reporting the creation of the component',
        label='date of creation',
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        super().normalize(archive, logger)


class Item(FabricationChemical):
    m_def = Section(
        a_eln={
            'properties': {
                'order': [
                    'name',
                    'description',
                    'chemical_formula',
                    'lab_id',
                    'datetime',
                    'id_wafer_parent',
                    'shapeType',
                    'notes',
                ],
            },
        }
    )
    lab_id = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    datetime = Quantity(
        a_eln={'component': 'DateTimeEditQuantity'},
        description='Date reporting the creation of the component',
        label='date of creation',
    )
    id_wafer_parent = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    shapeType = Quantity(
        type=MEnum(
            [
                'Wafer with flat standard',
                'Wafer with flat JEIDA',
                'Rectangle shape',
                '1/2 wafer',
                '1/4 wafer',
                'Fragment',
                'Square shape',
                'Powder',
                'Wafer with Notch standard',
                'Other (specify in notes)',
            ]
        ),
        a_eln={'component': 'EnumEditQuantity'},
    )
    notes = Quantity(
        type=str,
        a_eln={'component': 'RichTextEditQuantity'},
    )
    geometric_properties = SubSection(
        section_def=Contour,
        repeats=False,
    )
    components = SubSection(
        section_def=ItemComponent,
        description='If your item is assembly describe here each component',
        repeats=True,
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        super().normalize(archive, logger)


m_package.__init_metainfo__()
